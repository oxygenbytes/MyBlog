---
title: "[148]æ’åºé“¾è¡¨"
date: 2021-02-27 10:22:35+08:00
draft: false
tags:
  - Leetcode
---
```cpp
//ç»™ä½ é“¾è¡¨çš„å¤´ç»“ç‚¹ head ï¼Œè¯·å°†å…¶æŒ‰ å‡åº æ’åˆ—å¹¶è¿”å› æ’åºåçš„é“¾è¡¨ ã€‚ 
//
// è¿›é˜¶ï¼š 
//
// 
// ä½ å¯ä»¥åœ¨ O(n log n) æ—¶é—´å¤æ‚åº¦å’Œå¸¸æ•°çº§ç©ºé—´å¤æ‚åº¦ä¸‹ï¼Œå¯¹é“¾è¡¨è¿›è¡Œæ’åºå—ï¼Ÿ 
// 
//
// 
//
// ç¤ºä¾‹ 1ï¼š 
//
// 
//è¾“å…¥ï¼šhead = [4,2,1,3]
//è¾“å‡ºï¼š[1,2,3,4]
// 
//
// ç¤ºä¾‹ 2ï¼š 
//
// 
//è¾“å…¥ï¼šhead = [-1,5,3,4,0]
//è¾“å‡ºï¼š[-1,0,3,4,5]
// 
//
// ç¤ºä¾‹ 3ï¼š 
//
// 
//è¾“å…¥ï¼šhead = []
//è¾“å‡ºï¼š[]
// 
//
// 
//
// æç¤ºï¼š 
//
// 
// é“¾è¡¨ä¸­èŠ‚ç‚¹çš„æ•°ç›®åœ¨èŒƒå›´ [0, 5 * 104] å†… 
// -105 <= Node.val <= 105 
// 
// Related Topics æ’åº é“¾è¡¨ 
// ğŸ‘ 1011 ğŸ‘ 0

/*
* 148 æ’åºé“¾è¡¨
* 2021-02-27 10:22:35
* @author oxygenbytes
*/ 
#include "leetcode.h" 
//leetcode submit region begin(Prohibit modification and deletion)
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        int n = 0;
        for(auto p = head; p;p = p->next) n++;

        auto dummy = new ListNode(-1);
        dummy->next = head;

        for(int i = 1;i < n;i *= 2){
            auto cur = dummy;
            for(int j = 0;i + j < n;j += i * 2){
                auto first = cur->next;
                auto second = first;
                for(int k = 0;k < i;k++) second = second->next;

                int f = 0, s = 0;
                while(f < i && s < i && second){
                    if(first->val <= second->val){
                        cur->next = first;
                        cur = first;
                        first = first->next;
                        f++;
                    }else{
                        cur->next = second;
                        cur = second;
                        second = second->next;
                        s++;
                    }
                }
                while(f < i){
                    cur->next = first;
                    cur = first;
                    first = first->next;
                    f++;
                }
                while(s < i && right){
                    cur->next = second;
                    cur = second;
                    second = second->next;
                    s++;
                }
                cur->next = second; // after reverse second is the head
            }
        }
        return dummy->next;
    }
};

class Solution2 {
public:
    ListNode* sortList(ListNode* head) {
        if(!head || !head->next) return head;

        auto slow = head, fast = head;

        while(fast->next && fast->next->next){
            slow = slow->next;
            fast = fast->next->next;
        }
        auto newHead = slow->next;
        slow->next = nullptr;
        return merge(sortList(head), sortList(newHead));
    }

    ListNode* merge(ListNode* a, ListNode* b){
        auto dummy = new ListNode(-1);
        auto cur = dummy;

        while(a && b){
            if(a->val < b->val){
                cur->next = a;
                a = a->next;
            }else{
                cur->next = b;
                b = b->next;
            }
            cur = cur->next;
        }
        if(a) cur->next = a;
        if(b) cur->next = b;
        return dummy->next;
    }
};
//leetcode submit region end(Prohibit modification and deletion)
     
```
